#ifndef _ABB_ROBOTNODE_ROBOTCONTROLLER_HPP_
#define _ABB_ROBOTNODE_ROBOTCONTROLLER_HPP_

#include <iostream>
#include <vector>
#include <algorithm>
#include <thread>
#include <mutex>
#include <condition_variable>
#include <chrono>

#include <errno.h>
#include <fcntl.h>
#include <string>
#include <stdlib.h>
#include <stdio.h>
#include <time.h>
#include <arpa/inet.h>
#include <sys/socket.h>
#include <sys/types.h>
#include <math.h>

#include <ros/ros.h>
#include <sensor_msgs/JointState.h>
#include <geometry_msgs/PoseStamped.h>
#include <geometry_msgs/TwistStamped.h>

#include "egm.pb.h" // Generated by Protobuf
#include "abb_robotnode/Services.hpp"
#include "abb_robotnode/egm/PracticalSocket.h"

// ABB robot models
#define IRB120        0b0001
#define IRB1600       0b0010
#define IRB14000      0b0100

// Communication tasks
#define INFO_SERVER       0
#define MOTION_SERVER     1
#define LOGGER_SERVER     2

// Maximum buffer size for talking to robot
#define MAX_BUFFER        1400
#define ID_CODE_MAX       999
#define SERVER_BAD_MSG    0
#define SERVER_OK         1
#define SERVER_COLLISION  2
#define SERVER_BAD_IK     3
#define SERVER_BAD_FK     4

// EGM modes
#define EGM_OFF                0
#define EGM_CART_POS_AUTO      1
#define EGM_JOINT_POS_AUTO     2
#define EGM_CART_POS_MANUAL    3
#define EGM_CART_VEL_MANUAL    4
#define EGM_JOINT_POS_MANUAL   5
#define EGM_JOINT_VEL_MANUAL   6

// Math
#define PI 3.1415926535898
#define DEG2RAD (PI / 180.0)
#define RAD2DEG (180.0 / PI)

class RobotController
{
  public:
    // Declared in RobotController.cpp
    RobotController(ros::NodeHandle* n);
    virtual ~RobotController();

    bool init(std::string id = "");

    SERVICE_FUNCTION_LIST()
    SERVICE_AUX_LIST()

    // End of program
    void joinThreads();

    ros::NodeHandle* node;
    std::string name, root, msgHeader, ip;
    int model;

  private:
    // Initialization
    bool readModel();
    void prepareLogs();
    bool sendDefaultConfiguration();
    void advertiseTopics();
    void advertiseServices();
    void advertiseService(std::string name, auto func, int compatibleModels);

    // Common for all servers
    std::vector<ros::ServiceServer> serviceHandlers;
    char errorReply[MAX_BUFFER];
    ros::Publisher currentPoseHandler, currentJointsHandler;
    ros::Subscriber targetPoseHandler, targetTwistHandler, targetJointsHandler;
    geometry_msgs::PoseStamped receivedPose, currentPose, targetPose, sentPose;
    geometry_msgs::TwistStamped targetTwist, sentTwist;
    sensor_msgs::JointState receivedJoints, currentJoints, targetJoints, currentTargetJoints, sentJoints;
    std::mutex currentPoseMutex, currentJointsMutex;

    // Info server
    int infoPort, infoSocket;
    bool infoConnected;
    char infoMsg[MAX_BUFFER], infoReply[MAX_BUFFER];
    std::mutex infoMutex;

    // Motion server
    int motionPort, motionSocket;
    bool motionConnected;
    char motionMsg[MAX_BUFFER], motionReply[MAX_BUFFER];
    std::mutex motionMutex;

    // Motion parameters
    double maxTcpSpeed, maxOriSpeed, maxJointSpeed;
    double currentTool[7], currentWobj[7], currentInertia[7];
    int currentZone;

    // Logger
    int loggerPort, loggerSocket;
    bool loggerConnected, useLogger;
    char loggerReply[MAX_BUFFER];
    char* loggerReplyPointer;
    std::thread loggerThread;

    void loggerMain();
    void loggerCallback(const ros::TimerEvent&);

    // EGM
    double egmHz = 250.0;
    int egmPort, egmMode;
    std::string egmSourceAddr;
    unsigned short egmSourcePort;
    UDPSocket* egmSocket;
    bool egmFirst;
    int egmMsgSize, egmTargetSeq, egmSensorSeq, egmRandNumber;
    uint32_t egmStartTick;
    char egmReply[MAX_BUFFER];
    std::string egmMsg;
    std::thread egmThread;
    std::condition_variable egmStartCV, egmStartedCV;
    std::mutex egmModeMutex, egmStartMutex, egmStartedMutex, targetPoseMutex, targetTwistMutex, targetJointsMutex;
    abb::egm::EgmRobot lastEgmRobot;
    abb::egm::EgmSensor lastEgmSensor;
    abb::egm::EgmFeedBack lastEgmFeedBack;
    ros::Time lastEgmTime;
    ros::Publisher sentPoseHandler, sentTwistHandler, sentJointsHandler;

    void egmMain();
    void egmConnect();
    void egmDisconnect();
    std::string egmModeName();
    void egmLoadManualTargetPose(const geometry_msgs::PoseStamped& data);
    void egmLoadManualTargetTwist(const geometry_msgs::TwistStamped& data);
    void egmLoadManualTargetJoints(const sensor_msgs::JointState& data);
    void egmFlushRobotData();
    void egmSendTarget();
    void egmUpdateCurrentPose();
    void egmUpdateCurrentJoints();
    void egmSendTargetPose();
    void egmSendTargetTwist();
    void egmSendTargetJoints();
    uint32_t egmGetSensorTick();
    void egmSentPoseToEgmSensor();
    void egmSentTwistToEgmSensor();
    void egmSentJointsToEgmSensor();
    void egmSentJointsVelocityToEgmSensor();

    // Communication for motion/info servers
    int generateRandNumber();
    bool connectServer(int& socket, int port, int channel, bool& status);
    bool sendAndReceive(int& sock, int channel, std::mutex& mutex, char *message, int messageLength, char* reply, int idCode);
    bool sendInfo(int randNumber);
    bool sendMotion(int randNumber);
    bool receiveOnly(int& sock, int channel, std::mutex& mutex, char *message, int messageLength, char* reply, int idCode);
    bool receive(int& sock, int channel, std::mutex& mutex, char *message, int messageLength, char* reply, int idCode);
    bool receiveMotion(int randNumber);
};

#endif
